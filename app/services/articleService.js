const { VertexAI } = require('@google-cloud/vertexai');
const { ApiError } = require('../utils/errorHandler');
const config = require('../../config');

const vertexAI = new VertexAI({
  project: config.ai.projectId,
  location: config.ai.location
});
const PROMPTS = {
  hindi: (title, description) => `рдЖрдк рдПрдХ рд╡рд┐рд╢реЗрд╖рдЬреНрдЮ SEO рдФрд░ рд╕рдорд╛рдЪрд╛рд░ рд╕рдВрдкрд╛рджрдХ рд╣реИрдВред рдЖрдкрдХрд╛ рдХрд╛рд░реНрдп рджрд┐рдП рдЧрдП 'рд╢реАрд░реНрд╖рдХ' рдФрд░ 'рд╡рд┐рд╡рд░рдг' рдХреЛ рдорд┐рд▓рд╛рдХрд░ рдкреВрд░реА рддрд░рд╣ рд╕реЗ рдЕрдкрдиреЗ рд╢рдмреНрджреЛрдВ рдореЗрдВ рдПрдХ рдирдпрд╛, рдЖрдХрд░реНрд╖рдХ рд╢реАрд░реНрд╖рдХ рдФрд░ рд╕рд╛рд░рдЧрд░реНрднрд┐рдд рд╕рд╛рд░рд╛рдВрд╢ рддреИрдпрд╛рд░ рдХрд░рдирд╛ рд╣реИред

**рдирд┐рд░реНрджреЗрд╢:**
1.  рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рдХреЗрд╡рд▓ рдПрдХ рдорд╛рдиреНрдп JSON рдСрдмреНрдЬреЗрдХреНрдЯ рд╣реЛрдиреА рдЪрд╛рд╣рд┐рдПред
2.  рдХрд┐рд╕реА рднреА рддрд░рд╣ рдХрд╛ рдорд╛рд░реНрдХрдбрд╛рдЙрди, рдХреЛрдб рдмреНрд▓реЙрдХ рдпрд╛ рдЕрддрд┐рд░рд┐рдХреНрдд рдЯреЗрдХреНрд╕реНрдЯ рди рдЬреЛрдбрд╝реЗрдВред
3.  **рдореВрд▓ рд╡рд┐рд╡рд░рдг рд╕реЗ рд╕реАрдзреЗ рд╡рд╛рдХреНрдпрд╛рдВрд╢ рдпрд╛ рд╡рд╛рдХреНрдп рдХреЙрдкреА рди рдХрд░реЗрдВред**
4.  рдирдпрд╛ рд╢реАрд░реНрд╖рдХ рдЖрдХрд░реНрд╖рдХ, SEO-рдЕрдиреБрдХреВрд▓ (SEO-friendly) рд╣реЛрдирд╛ рдЪрд╛рд╣рд┐рдП рдФрд░ рд╕рдорд╛рдЪрд╛рд░ рдХреЗ рдореВрд▓ рд╕рд╛рд░ рдХреЛ рдкреНрд░рд╕реНрддреБрдд рдХрд░рдирд╛ рдЪрд╛рд╣рд┐рдПред
5.  рд╕рд╛рд░рд╛рдВрд╢ 50 рд╕реЗ 60 рд╢рдмреНрджреЛрдВ рдореЗрдВ, **рдЖрдкрдХреЗ рдЕрдкрдиреЗ рд╢рдмреНрджреЛрдВ рдореЗрдВ рд▓рд┐рдЦрд╛ рдЬрд╛рдирд╛ рдЪрд╛рд╣рд┐рдП**, рдЬрд┐рд╕рдореЗрдВ рдореВрд▓ рд╢реАрд░реНрд╖рдХ рдФрд░ рд╡рд┐рд╡рд░рдг рджреЛрдиреЛрдВ рдХреА рдореБрдЦреНрдп рдЬрд╛рдирдХрд╛рд░реА рд╢рд╛рдорд┐рд▓ рд╣реЛред
6.  рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рдХрд╛ рдкреНрд░рд╛рд░реВрдк рдмрд┐рд▓реНрдХреБрд▓ рдЗрд╕ рддрд░рд╣ рд╣реЛрдирд╛ рдЪрд╛рд╣рд┐рдП:

\`\`\`json
{
  "title": "<рдПрдХ рдЖрдХрд░реНрд╖рдХ рдФрд░ рдЕрдиреВрдард╛ рд╣рд┐рдВрджреА рд╢реАрд░реНрд╖рдХ>",
  "summary": "<рдпрд╣рд╛рдБ рд╣рд┐рдВрджреА рдореЗрдВ 50-60 рд╢рдмреНрджреЛрдВ рдХрд╛ рд╕рд╛рд░рд╛рдВрд╢, рдкреВрд░реА рддрд░рд╣ рд╕реЗ рдЕрдкрдиреЗ рд╢рдмреНрджреЛрдВ рдореЗрдВ>"
}
\`\`\`

--- рд▓реЗрдЦ рдХрд╛ рд╡рд┐рд╡рд░рдг ---
**рд╢реАрд░реНрд╖рдХ:** ${title}
**рд╡рд┐рд╡рд░рдг:** ${description}
--- JSON рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ ---`,

  english: (title, description) => `You are an expert SEO and news editor. Your task is to synthesize the provided 'Title' and 'Description' into a completely new, paraphrased title and summary.

**Instructions:**
1.  Your output must be only a single, valid JSON object.
2.  Do NOT include markdown, code blocks, or any other text outside the JSON.
3.  **Do not copy phrases or sentences directly from the original description.**
4.  The new title should be compelling, SEO-friendly, and capture the core essence of the news.
5.  The summary must be a concise 50-60 words, **written in your own words**, that integrates the key information from both the original title and description.
6. You must paraphrase the title and description/content fully; avoid any direct quotations from the source.
7.  The response must exactly match this format:

\`\`\`json
{
  "title": "<A compelling and unique SEO-friendly title in English>",
  "summary": "<A 50тАУ60 word summary in English, fully paraphrased>"
}
\`\`\`

--- Article Details ---
**Title:** ${title}
**Description:** ${description}
--- JSON Response ---`
};


function stripHtml(html) {
  if (!html) return '';
  return html.replace(/<[^>]*>?/gm, '').replace(/&nbsp;/g, ' ').trim();
}


function extractArticleContent(article) {
  const title = article.title || article.sTitle || article.shortTitle || 'Untitled';
  const description = article.description || article.sDescription  || '';
  const content =  article.sContent || article.content || '';
  return { title, description, content };
}


function _parseJsonWithFallback(rawText) {
  const cleanedText = rawText
    .replace(/^```json/i, '')
    .replace(/^```/, '')
    .replace(/```$/, '')
    .trim();

  try {
    let parsed = JSON.parse(cleanedText);
    if (typeof parsed === 'string') {
      parsed = JSON.parse(parsed); 
    }
    return parsed;
  } catch (err) {
    console.warn('тЭМ JSON.parse failed. Attempting regex fallbackтАж');
    const match = cleanedText.match(/"title"\s*:\s*"([^"]+)"\s*,\s*"summary"\s*:\s*"([^"]+)"/i);
    if (match && match[1] && match[2]) {
      return { title: match[1].trim(), summary: match[2].trim() };
    }
    throw new Error('Failed to parse summary JSON from model response.');
  }
}


const summarizeSingleArticle = async (article, language = 'english', retryCount = 0) => {
  const { 
    maxRetries, 
    minContentLength, 
    maxInputLength, 
    retryDelay 
  } = config.ai;

  try {
    const model = vertexAI.getGenerativeModel({
      model: config.ai.model,
      generationConfig: {
        maxOutputTokens: config.ai.maxTokens,
        temperature: config.ai.temperature,
      }
    });

    const { title, description, content } = extractArticleContent(article);
    let cleanContent = stripHtml(description);

    if (content) {
      const fullContent = stripHtml(content);
      if (fullContent.length > cleanContent.length) {
        cleanContent = fullContent;
      }
    }

    if (!cleanContent || cleanContent.length < minContentLength) {
      throw new Error(`Article content is too short (${cleanContent.length} chars) or missing.`);
    }
    
    const truncatedContent = cleanContent.substring(0, maxInputLength);

    const prompt = PROMPTS[language](title, truncatedContent);
    if (!prompt) {
      throw new Error(`No prompt available for the selected language: "${language}"`);
    }
    
    const result = await model.generateContent(prompt);
    const response = result.response;

    if (!response || !response.text) {
      const finishReason = response?.promptFeedback?.blockReason || 'UNKNOWN_REASON';
      const safetyRatings = response?.promptFeedback?.safetyRatings || [];
      console.warn(`тЪая╕П Model returned no text. Finish Reason: ${finishReason}`, { safetyRatings });
      throw new Error(`Content blocked by model for safety reasons: ${finishReason}`);
    }

    const rawText = response.text().trim();
    console.log('ЁЯзк Vertex AI raw output:', rawText);

    if (!rawText || rawText.length < 10) {
      throw new Error('Model returned an empty or too-short response.');
    }

    return _parseJsonWithFallback(rawText);

  } catch (error) {
    const articleTitle = article.title || article.sTitle || 'Untitled';
    console.warn(`тЪая╕П Error on attempt ${retryCount + 1} for article "${articleTitle}":`, error.message);

    if (retryCount < maxRetries) {
      console.log(`ЁЯФБ Retrying summarization for "${articleTitle}" after ${retryDelay}ms...`);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      return summarizeSingleArticle(article, language, retryCount + 1);
    }

    return {
      title: articleTitle,
      summary: 'Summary not generated due to repeated model failure.'
    };
  }
};


const summarizeArticles = async (articles, language = 'english') => {
  try {
    const summarizationPromises = articles.map(article => 
      summarizeSingleArticle(article, language)
    );
    const results = await Promise.allSettled(summarizationPromises);
    
    const summarizedArticles = results.map((result, index) => {
      if (result.status === 'fulfilled') {
        return result.value;
      }
      const articleTitle = articles[index].title || articles[index].sTitle || 'Untitled';
      console.error(`Final failure for article "${articleTitle}":`, result.reason);
      return {
        title: articleTitle,
        summary: 'Summary failed to generate for this article.'
      };
    });

    return summarizedArticles;
  } catch (error) {
    console.error('Error in batch summarization orchestrator:', error);
    throw new ApiError(500, 'Failed to summarize articles');
  }
};

const validateApiKey = async () => {
  try {
    if (!config.ai.projectId) {
      throw new Error('Google Cloud Project ID is not configured');
    }
    const model = vertexAI.getGenerativeModel({ model: config.ai.model });
    await model.generateContent("Hello");
    return true;
  } catch (error) {
    console.error('Vertex AI validation failed:', error.message);
    return false;
  }
};

const LONG_ARTICLE_PROMPTS = {
  hindi: (combinedContent) => `рдЖрдк рдПрдХ рд╡рд┐рд╢реЗрд╖рдЬреНрдЮ рд╕рдорд╛рдЪрд╛рд░ рд╕рдВрдкрд╛рджрдХ рд╣реИрдВред рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рд▓реЗрдЦреЛрдВ рдХреЛ рдПрдХ рдПрдХреАрдХреГрдд рд╕рдорд╛рдЪрд╛рд░ рд╕рд╛рд░рд╛рдВрд╢ рдореЗрдВ рд╕рдВрдХреНрд╖реЗрдкрд┐рдд рдХрд░реЗрдВ рдЬреЛ рдмрд┐рд▓реНрдХреБрд▓ 140-160 рд╢рдмреНрджреЛрдВ рдореЗрдВ рд╣реЛ рдФрд░ рд╕рднреА рдорд╣рддреНрд╡рдкреВрд░реНрдг рдШрдЯрдирд╛рдУрдВ рдХреЛ рдХрд╡рд░ рдХрд░реЗред

**рдорд╣рддреНрд╡рдкреВрд░реНрдг рдирд┐рд░реНрджреЗрд╢:**
1. рдХреЗрд╡рд▓ рдПрдХ рдорд╛рдиреНрдп JSON рдСрдмреНрдЬреЗрдХреНрдЯ рдкреНрд░рджрд╛рди рдХрд░реЗрдВ
2. рдХреЛрдИ рдорд╛рд░реНрдХрдбрд╛рдЙрди, рдХреЛрдб рдмреНрд▓реЙрдХ рдпрд╛ рдЕрддрд┐рд░рд┐рдХреНрдд рдЯреЗрдХреНрд╕реНрдЯ рди рдЬреЛрдбрд╝реЗрдВ
3. рд╕рд╛рд░рд╛рдВрд╢ рдмрд┐рд▓реНрдХреБрд▓ 180-200 рд╢рдмреНрджреЛрдВ рдореЗрдВ рд╣реЛрдирд╛ рдЪрд╛рд╣рд┐рдП
4. рд╕рднреА рд▓реЗрдЦреЛрдВ рдХреА рдореБрдЦреНрдп рдЬрд╛рдирдХрд╛рд░реА рдХреЛ рдПрдХ рд╕рд╛рде рдорд┐рд▓рд╛рдПрдВ
5. рдпрджрд┐ рд▓реЗрдЦ рдЦрд╛рд▓реА рдпрд╛ рдЕрдкрд░реНрдпрд╛рдкреНрдд рд╣реИрдВ, рддреЛ рдЙрдкрд▓рдмреНрдз рдЬрд╛рдирдХрд╛рд░реА рдХреЗ рд╕рд╛рде рдХрд╛рдо рдХрд░реЗрдВ

рд╕рдВрдХреНрд╖реЗрдкрд┐рдд рдХрд░рдиреЗ рд╡рд╛рд▓реЗ рд▓реЗрдЦ:
${combinedContent}

рдХреЗрд╡рд▓ рдЗрд╕ рдкреНрд░рд╛рд░реВрдк рдореЗрдВ JSON рдкреНрд░рддрд┐рдХреНрд░рд┐рдпрд╛ рджреЗрдВ:
{
  "title": "<рдПрдХреАрдХреГрдд рд╕рдорд╛рдЪрд╛рд░ рдХреЗ рд▓рд┐рдП рдЖрдХрд░реНрд╖рдХ рд╣рд┐рдВрджреА рд╢реАрд░реНрд╖рдХ>",
  "summary": "<140-160 рд╢рдмреНрджреЛрдВ рдореЗрдВ рдПрдХреАрдХреГрдд рд╣рд┐рдВрджреА рд╕рд╛рд░рд╛рдВрд╢>"
}`,

  english: (combinedContent) => `You are a professional news editor. Summarize the following articles into a single, cohesive news summary of exactly 140-160 words that captures all the important happenings.

**Critical Instructions:**
1. Provide only a valid JSON object
2. Do NOT include markdown, code blocks, or any additional text
3. Summary must be exactly 140-160 words
4. Combine key information from all articles into one coherent narrative
5. If articles are empty or insufficient, work with available information
6. Handle duplicate information by mentioning it once
7. Prioritize the most newsworthy events if content is extensive

Articles to summarize:
${combinedContent}

Provide only a JSON response in this exact format:
{
  "title": "<A compelling headline for the consolidated news>",
  "summary": "<140-160 word unified summary covering all important events>"
}`
};

const summarizeLongArticles = async (articles, language = 'english', retryCount = 0) => {
  const { maxRetries, retryDelay } = config.ai;
  
  try {
    if (!articles || !Array.isArray(articles) || articles.length === 0) {
      throw new Error('No articles provided for summarization');
    }

    const model = vertexAI.getGenerativeModel({
      model: config.ai.model,
      generationConfig: {
        maxOutputTokens: config.ai.maxTokens,
        temperature: config.ai.temperature,
      }
    });

    // Combine all articles into a single content block
    const combinedContent = articles.map((article, index) => {
      const { title, description, content } = extractArticleContent(article);
      let cleanContent = stripHtml(content || description || '');
      if (!cleanContent.trim()) {
        cleanContent = 'Content not available';
      }
      
      if (cleanContent.length > 1000) {
        cleanContent = cleanContent.substring(0, 1000) + '...';
      }
      
      return `Article ${index + 1}: ${title}\n${cleanContent}`;
    }).join('\n\n');

    const prompt = LONG_ARTICLE_PROMPTS[language](combinedContent);
    if (!prompt) {
      throw new Error(`No prompt available for language: ${language}`);
    }

    const result = await model.generateContent(prompt);
    const response = result.response;

    if (!response || !response.text) {
      const finishReason = response?.promptFeedback?.blockReason || 'UNKNOWN_REASON';
      throw new Error(`Content blocked by model: ${finishReason}`);
    }

    const rawText = response.text().trim();
    if (!rawText || rawText.length < 10) {
      throw new Error('Model returned empty or too-short response');
    }

    return _parseJsonWithFallback(rawText);

  } catch (error) {
    console.warn(`тЪая╕П Error on attempt ${retryCount + 1} for long articles summarization:`, error.message);

    if (retryCount < maxRetries) {
      console.log(`ЁЯФБ Retrying long articles summarization after ${retryDelay}ms...`);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      return summarizeLongArticles(articles, language, retryCount + 1);
    }

    // Fallback response for complete failure
    const fallbackTitle = language === 'hindi' ? 'рд╕рдорд╛рдЪрд╛рд░ рд╕рд╛рд░рд╛рдВрд╢ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ' : 'News Summary Unavailable';
    const fallbackSummary = language === 'hindi' 
      ? 'рддрдХрдиреАрдХреА рд╕рдорд╕реНрдпрд╛ рдХреЗ рдХрд╛рд░рдг рд╕рдорд╛рдЪрд╛рд░ рд╕рд╛рд░рд╛рдВрд╢ рддреИрдпрд╛рд░ рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрд╛ред'
      : 'News summary could not be generated due to technical issues.';
    
    return {
      title: fallbackTitle,
      summary: fallbackSummary
    };
  }
};

module.exports = {
  summarizeArticles,
  summarizeSingleArticle,
  summarizeLongArticles,
  validateApiKey
};