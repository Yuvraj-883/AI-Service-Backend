const { GoogleGenerativeAI } = require('@google/generative-ai');
const { ApiError } = require('../utils/errorHandler');
const config = require('../../config');

const genAI = new GoogleGenerativeAI(config.ai.apiKey);
const PROMPTS = {
  hindi: (title, description) => `‡§Ü‡§™ ‡§è‡§ï ‡§µ‡§ø‡§∂‡•á‡§∑‡§ú‡•ç‡§û SEO ‡§î‡§∞ ‡§∏‡§Æ‡§æ‡§ö‡§æ‡§∞ ‡§∏‡§Ç‡§™‡§æ‡§¶‡§ï ‡§π‡•à‡§Ç‡•§ ‡§Ü‡§™‡§ï‡§æ ‡§ï‡§æ‡§∞‡•ç‡§Ø ‡§¶‡§ø‡§è ‡§ó‡§è '‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï' ‡§î‡§∞ '‡§µ‡§ø‡§µ‡§∞‡§£' ‡§ï‡•ã ‡§Æ‡§ø‡§≤‡§æ‡§ï‡§∞ ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§Ö‡§™‡§®‡•á ‡§∂‡§¨‡•ç‡§¶‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§®‡§Ø‡§æ, ‡§Ü‡§ï‡§∞‡•ç‡§∑‡§ï ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§î‡§∞ ‡§∏‡§æ‡§∞‡§ó‡§∞‡•ç‡§≠‡§ø‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡§®‡§æ ‡§π‡•à‡•§

**‡§®‡§ø‡§∞‡•ç‡§¶‡•á‡§∂:**
1.  ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡•á‡§µ‡§≤ ‡§è‡§ï ‡§Æ‡§æ‡§®‡•ç‡§Ø JSON ‡§ë‡§¨‡•ç‡§ú‡•á‡§ï‡•ç‡§ü ‡§π‡•ã‡§®‡•Ä ‡§ö‡§æ‡§π‡§ø‡§è‡•§
2.  ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä ‡§§‡§∞‡§π ‡§ï‡§æ ‡§Æ‡§æ‡§∞‡•ç‡§ï‡§°‡§æ‡§â‡§®, ‡§ï‡•ã‡§° ‡§¨‡•ç‡§≤‡•â‡§ï ‡§Ø‡§æ ‡§Ö‡§§‡§ø‡§∞‡§ø‡§ï‡•ç‡§§ ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§® ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‡•§
3.  **‡§Æ‡•Ç‡§≤ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§∏‡•á ‡§∏‡•Ä‡§ß‡•á ‡§µ‡§æ‡§ï‡•ç‡§Ø‡§æ‡§Ç‡§∂ ‡§Ø‡§æ ‡§µ‡§æ‡§ï‡•ç‡§Ø ‡§ï‡•â‡§™‡•Ä ‡§® ‡§ï‡§∞‡•á‡§Ç‡•§**
4.  ‡§®‡§Ø‡§æ ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§Ü‡§ï‡§∞‡•ç‡§∑‡§ï, SEO-‡§Ö‡§®‡•Å‡§ï‡•Ç‡§≤ (SEO-friendly) ‡§π‡•ã‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è ‡§î‡§∞ ‡§∏‡§Æ‡§æ‡§ö‡§æ‡§∞ ‡§ï‡•á ‡§Æ‡•Ç‡§≤ ‡§∏‡§æ‡§∞ ‡§ï‡•ã ‡§™‡•ç‡§∞‡§∏‡•ç‡§§‡•Å‡§§ ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è‡•§
5.  ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ 50 ‡§∏‡•á 60 ‡§∂‡§¨‡•ç‡§¶‡•ã‡§Ç ‡§Æ‡•á‡§Ç, **‡§Ü‡§™‡§ï‡•á ‡§Ö‡§™‡§®‡•á ‡§∂‡§¨‡•ç‡§¶‡•ã‡§Ç ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§ñ‡§æ ‡§ú‡§æ‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è**, ‡§ú‡§ø‡§∏‡§Æ‡•á‡§Ç ‡§Æ‡•Ç‡§≤ ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï ‡§î‡§∞ ‡§µ‡§ø‡§µ‡§∞‡§£ ‡§¶‡•ã‡§®‡•ã‡§Ç ‡§ï‡•Ä ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§π‡•ã‡•§
6.  ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡§æ ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™ ‡§¨‡§ø‡§≤‡•ç‡§ï‡•Å‡§≤ ‡§á‡§∏ ‡§§‡§∞‡§π ‡§π‡•ã‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è:

\`\`\`json
{
  "title": "<‡§è‡§ï ‡§Ü‡§ï‡§∞‡•ç‡§∑‡§ï ‡§î‡§∞ ‡§Ö‡§®‡•Ç‡§†‡§æ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï>",
  "summary": "<‡§Ø‡§π‡§æ‡§Å ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç 50-60 ‡§∂‡§¨‡•ç‡§¶‡•ã‡§Ç ‡§ï‡§æ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂, ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§Ö‡§™‡§®‡•á ‡§∂‡§¨‡•ç‡§¶‡•ã‡§Ç ‡§Æ‡•á‡§Ç>"
}
\`\`\`

--- ‡§≤‡•á‡§ñ ‡§ï‡§æ ‡§µ‡§ø‡§µ‡§∞‡§£ ---
**‡§∂‡•Ä‡§∞‡•ç‡§∑‡§ï:** ${title}
**‡§µ‡§ø‡§µ‡§∞‡§£:** ${description}
--- JSON ‡§™‡•ç‡§∞‡§§‡§ø‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ---`,

  english: (title, description) => `You are an expert SEO and news editor. Your task is to synthesize the provided 'Title' and 'Description' into a completely new, paraphrased title and summary.

**Instructions:**
1.  Your output must be only a single, valid JSON object.
2.  Do NOT include markdown, code blocks, or any other text outside the JSON.
3.  **Do not copy phrases or sentences directly from the original description.**
4.  The new title should be compelling, SEO-friendly, and capture the core essence of the news.
5.  The summary must be a concise 50-60 words, **written in your own words**, that integrates the key information from both the original title and description.
6.  The response must exactly match this format:

\`\`\`json
{
  "title": "<A compelling and unique SEO-friendly title in English>",
  "summary": "<A 50‚Äì60 word summary in English, fully paraphrased>"
}
\`\`\`

--- Article Details ---
**Title:** ${title}
**Description:** ${description}
--- JSON Response ---`
};


function stripHtml(html) {
  if (!html) return '';
  return html.replace(/<[^>]*>?/gm, '').replace(/&nbsp;/g, ' ').trim();
}


function extractArticleContent(article) {
  const title = article.title || article.sTitle || article.shortTitle || 'Untitled';
  const description = article.description || article.sDescription  || '';
  const content =  article.sContent || article.content || '';
  return { title, description, content };
}


function _parseJsonWithFallback(rawText) {
  const cleanedText = rawText
    .replace(/^```json/i, '')
    .replace(/^```/, '')
    .replace(/```$/, '')
    .trim();

  try {
    let parsed = JSON.parse(cleanedText);
    if (typeof parsed === 'string') {
      parsed = JSON.parse(parsed); 
    }
    return parsed;
  } catch (err) {
    console.warn('‚ùå JSON.parse failed. Attempting regex fallback‚Ä¶');
    const match = cleanedText.match(/"title"\s*:\s*"([^"]+)"\s*,\s*"summary"\s*:\s*"([^"]+)"/i);
    if (match && match && match) {
      return { title: match.trim(), summary: match.trim() };
    }
    throw new Error('Failed to parse summary JSON from model response.');
  }
}


const summarizeSingleArticle = async (article, language = 'english', retryCount = 0) => {
  const { 
    maxRetries, 
    minContentLength, 
    maxInputLength, 
    retryDelay 
  } = config.ai;

  try {
    const model = genAI.getGenerativeModel({ 
      model: config.ai.model,
      generationConfig: {
        maxOutputTokens: config.ai.maxTokens,
        temperature: config.ai.temperature,
      }
    });

    const { title, description, content } = extractArticleContent(article);
    let cleanContent = stripHtml(description);

    if (content) {
      const fullContent = stripHtml(content);
      if (fullContent.length > cleanContent.length) {
        cleanContent = fullContent;
      }
    }

    if (!cleanContent || cleanContent.length < minContentLength) {
      throw new Error(`Article content is too short (${cleanContent.length} chars) or missing.`);
    }
    
    const truncatedContent = cleanContent.substring(0, maxInputLength);

    const prompt = PROMPTS[language](title, truncatedContent);
    if (!prompt) {
      throw new Error(`No prompt available for the selected language: "${language}"`);
    }
    
    const result = await model.generateContent(prompt);
    const response = result.response;

    if (!response || !response.text) {
      const finishReason = response?.promptFeedback?.blockReason || 'UNKNOWN_REASON';
      const safetyRatings = response?.promptFeedback?.safetyRatings || [];
      console.warn(`‚ö†Ô∏è Model returned no text. Finish Reason: ${finishReason}`, { safetyRatings });
      throw new Error(`Content blocked by model for safety reasons: ${finishReason}`);
    }

    const rawText = response.text().trim();
    console.log('üß™ Gemini raw output:', rawText);

    if (!rawText || rawText.length < 10) {
      throw new Error('Model returned an empty or too-short response.');
    }

    return _parseJsonWithFallback(rawText);

  } catch (error) {
    const articleTitle = article.title || article.sTitle || 'Untitled';
    console.warn(`‚ö†Ô∏è Error on attempt ${retryCount + 1} for article "${articleTitle}":`, error.message);

    if (retryCount < maxRetries) {
      console.log(`üîÅ Retrying summarization for "${articleTitle}" after ${retryDelay}ms...`);
      await new Promise(resolve => setTimeout(resolve, retryDelay));
      return summarizeSingleArticle(article, language, retryCount + 1);
    }

    return {
      title: articleTitle,
      summary: 'Summary not generated due to repeated model failure.'
    };
  }
};


const summarizeArticles = async (articles, language = 'english') => {
  try {
    const summarizationPromises = articles.map(article => 
      summarizeSingleArticle(article, language)
    );
    const results = await Promise.allSettled(summarizationPromises);
    
    const summarizedArticles = results.map((result, index) => {
      if (result.status === 'fulfilled') {
        return result.value;
      }
      const articleTitle = articles[index].title || articles[index].sTitle || 'Untitled';
      console.error(`Final failure for article "${articleTitle}":`, result.reason);
      return {
        title: articleTitle,
        summary: 'Summary failed to generate for this article.'
      };
    });

    return summarizedArticles;
  } catch (error) {
    console.error('Error in batch summarization orchestrator:', error);
    throw new ApiError(500, 'Failed to summarize articles');
  }
};

const validateApiKey = async () => {
  try {
    if (!config.ai.apiKey) {
      throw new Error('Google API key is not configured');
    }
    const model = genAI.getGenerativeModel({ model: config.ai.model });
    await model.generateContent("Hello");
    return true;
  } catch (error) {
    console.error('Google API key validation failed:', error.message);
    return false;
  }
};

module.exports = {
  summarizeArticles,
  summarizeSingleArticle,
  validateApiKey
};